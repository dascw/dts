#ifndef DTS_UTILITIES_H
#define DTS_UTILITIES_H
/**
 * @defgroup utilities Utilities
 *
 * Components deemed generally useful. Includes pair, tuple,
 * forward/move helpers, ratio, function object, metaprogramming and
 * type traits, time, date, and memory functions.
 *
 * @todo add details on the enumeration method.
 * @todo list caveats of use (e.g. inefficient resizing of vectors etc.)
 * @todo add details on how to use.
 * @todo add details 
**/

#include <utility>
#include <functional>  // required  for std::ref
#include <vector>
#include <stdint.h>
#include <algorithm>
#include <typeinfo>

namespace dts {
    /**
     * @brief returns universal reference to container at requested index, type
     * deduced.
     */
    template<typename _Container, typename _Index>
    inline auto 
    uni_access(_Container&& __cntr, _Index __idx) -> 
            decltype(std::forward<_Container>(__cntr)[__idx]) {
        return std::forward<_Container>(__cntr)[__idx];
    }

    /**
     * @brief return size of an array as a compile-time constant. (The
     * array parameter has no name, because we care only abou the number of elements
     * it contains.)
     */
    template <typename _Tp, std::size_t _Sz>
    inline constexpr std::size_t 
    array_size(_Tp (&)[_Sz]) noexcept {
        return _Sz;
    }

    /**
     * Function template that takes an arbitrary enumerator and can return its value as
     * a compile time constant.
     * @note should in principle provide simplistic conversion of ENUM to size_t etc?
     * 
     * @todo Read through example for tuple access with scoped enumeration.
     */
    template<typename _Enum>
    constexpr typename std::underlying_type<_Enum>::type
    to_idx(_Enum __enum) noexcept {
        return static_cast<typename std::underlying_type<_Enum>::type>(__enum);
    }

    /**
     * @brief prevents rvalue delete.
     * @details "if you consider zeroing out pointers important, consider using destroy."
     *          http://www.stroustrup.com/bs_faq2.html @ why doesn't delete zero out its operand?
     * @example
     *        if we have: `delete (int*)10;`, the compiler will NOT catch this and will successfully compile.
     *        if we pass an rvalue to destroy, a compile time error will be generated by the asignment
     *        to nullptr.
     *                    destroy( (int*)10); // prevents rvalue delete when cast.
     * @note it's obvious when casting directly that this has the potential to crash a system, 
     *       and should not be carried out.
     */
    template<class _Tp>
    inline void
    destroy(_Tp*& __p) { delete __p; __p = nullptr; }

    /**
     * @brief provides compile time check that object of type _T1 can
     * @details http://www.stroustrup.com/bs_faq2.html#constraints
     * be assigned to object of type _T2.
     * @example has_value<deduced_type, actual_type>(); // generates error on false.
     * @note constraints and concepts are standard in C++20.
     */
    template <class _Tp1, class _Tp2>
    struct is_type {
        static void constraints(_Tp1 __a, _Tp2 __b) {
            _Tp2 c = __a; __b = __a; (void)c;
        }
        is_type() { void(*ptr)(_Tp1, _Tp2) = constraints; (void)ptr; }
    };

    // @note currently broken.
    // @todo fix.
#if 0
    /**
      * @brief dts_BUILD_GET_TYPE() : creates get_tuple method for simple enumeration
      * access of tuple members (removes requirement to constantly cast to accessable
      * value.
      * @details to use:
      *     1. add dts_BUILD_GET_TUPLE(enum_class) below your enum declaration.
      *     2. const auto& val = get_tuple<enum_class::enum_member>(tuple_object);
      */
    #define dts_BUILD_GET_TUPLE(_Enum_t) \
        template <_Enum_t key, typename _Tuple> \
        decltype(auto) 
        get_tuple(_Tuple &&__tuple) { \
            return std::get<static_cast<std::underlying_type_t<_Enum_t>>(key)>(__tuple); \
        } dts_EAT_SEMICOLON() 
#endif // 0
} 

#endif 
    // DTS_UTILITIES_H

/****************************************end of file****************************************/
